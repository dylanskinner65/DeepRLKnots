# -*- coding: utf-8 -*-
"""SliceRL_Copy1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1xzeCy58hbqAR7CXXhigB1I_elH17SILN

### Dependencies
"""

from tkinter.ttk import Progressbar
import numpy as np
from matplotlib import pyplot


from stable_baselines3.common.vec_env import DummyVecEnv
from stable_baselines3 import PPO
#from stable_baselines3.common.callbacks import ProgressBarCallback

"""### Random braid generator"""

import pandas as pd
import os
import csv
import random,re
from datetime import datetime


def random_band(index,start,end,band_sign = 0,conjugate_length_st_dev = 0.8,sgr_st_dev = 0.6):
    """
    Creates a random band for a braid of given index, where the band starts at strand number start, ends at band 
    number end, and has prescribed sign.  The conjugate_length_st_dev controls the distribution of the conjugate
    length, and sgr_st_dev controls the distribution of how many symmetric group relators of the form sigma^2 = 1
    are added into the conjugators.
    """
    # If the start strand number is higher than the end strand number, swap them.
    if start > end:     
        temp = start
        start = end
        end = temp
    # If no argumant is given for band sign, randomly select between -1 and 1.
    if band_sign == 0:  
        band_sign = np.random.choice([-1,1])
    # Randomly select the center of the band (the braid letter for the central crossing).
    center = np.random.randint(1,index)
    # Create lists of crossings needed on the 'left' and 'right' of the central crossing to connect the start
    # and end strands to it.
    if start == center:
        left_crossings = []
    elif start == center+1:
        left_crossings = [center]
    elif start<center:
        left_crossings = [jjj for jjj in range(start,center,1)]
    elif start > center+1:
        left_crossings = [jjj for jjj in range(start-1,center-1,-1)]
    if end == center+1:
        right_crossings = []
    elif end == center:
        right_crossings = [center]
    elif end<center:
        right_crossings = [jjj for jjj in range(end,center+1,1)]
    elif end > center+1:
        right_crossings = [jjj for jjj in range(end-1,center,-1)]
    band = []
    start_strand = start
    end_strand = end
    # Specify the directions we will be adding crossings in based on the central crossings location relative to the 
    # start and end strands.
    if center >= end:
        end_direction = 1
    else:
        end_direction = -1
    if center<start:
        start_direction = -1
    else:
        start_direction = 1
    # Build the conjugator by selecting crossings from the left and right crossing lists at random (when possible).
    while len(left_crossings)+len(right_crossings) > 0:
        if start_strand+1 == end_strand:
            if center >= end_strand:
                band.append(np.random.choice([-1,1])*right_crossings.pop(0))
                end_strand = end_strand+end_direction
            elif center<start_strand:
                band.append(np.random.choice([-1,1])*left_crossings.pop(0))
                start_strand = start_strand+start_direction
        else:
            coin = np.random.randint(0,2)
            if coin:
                if len(left_crossings) > 0:
                    band.append(np.random.choice([-1,1])*left_crossings.pop(0))
                    start_strand = start_strand+start_direction
                else:
                    band.append(np.random.choice([-1,1])*right_crossings.pop(0))
                    end_strand = end_strand+end_direction
            else:
                if len(right_crossings) > 0:
                    band.append(np.random.choice([-1,1])*right_crossings.pop(0))
                    end_strand = end_strand+end_direction
                else:
                    band.append(np.random.choice([-1,1])*left_crossings.pop(0))
                    start_strand = start_strand+start_direction
    # Determine the number of symmetric group relators to include in the conjugator (words of the form sigma^2).
    sgr_count = int(np.floor(np.abs(np.random.normal(0,sgr_st_dev))))
    possible_crossings = [jjj for jjj in range(1,index)]+[-jjj for jjj in range(1,index)]
    # Add the symmetric group relators into the conjugator.
    for iii in range(sgr_count):
        sign = np.random.choice([-1,1])
        location = np.random.randint(0,len(band)+2)
        crossing = np.random.choice(possible_crossings)
        # Create a conjugator for the symmetric group relator that will be insterted into the main conjugator.
        conjugate_length = int(np.floor(np.abs(np.random.normal(0,conjugate_length_st_dev))))
        conjugator = list(np.random.choice(possible_crossings,conjugate_length))
        inverse_conjugator = [-jjj for jjj in conjugator]
        inverse_conjugator.reverse()
        relator = conjugator+[sign*crossing,sign*crossing]+inverse_conjugator
        band[location:location] = relator
    inverse_band = [-jjj for jjj in band]
    inverse_band.reverse()
    full_band = band+[band_sign*center]+inverse_band
    return full_band


def insert_strand(braid,index,location,sign):
    """
    Function for inserting an unknotted, unlinked strand into a braid with given index, at a strand number 
    determined by the argument location.  The argument sign determines whether this strand will pass on top 
    of, or below the existing braid.
    """
    global log
    if location > index+1 or location<1:
      print('Location of inserted strand out of range.')
      return
    # Adjust all crossings which are to the right of the inserted strand.
    for jjj in range(len(braid)):
        if braid[jjj] >= np.abs(location):
            braid[jjj] = braid[jjj]+1
        if -braid[jjj] >= np.abs(location):
            braid[jjj] = braid[jjj]-1
    # Modify all crossings which are located next to the inserted strand, by adding a pair of neighboring crossings
    # around the affected strand.
    iii = 0
    while iii<len(braid):
        if np.abs(braid[iii]) == np.abs(location)-1:
            braid.insert(iii,sign*location)
            braid.insert(iii+2,-sign*location)
            iii = iii+3
        else:
            iii = iii+1
    #log = log+"New strand inserted at position "+str(location)+"\n"
    #log = log+str(braid)+"\n"
    return braid


def permutation_test(braid,index,stopping_index = -1):
    """
    Returns the permutation associated to a given braid with specified index.  The optional stopping_index allows 
    you to determine the permutation up to a certain point in the braid word (the word index should probably not
    be used here, since it has nothing to do with the actual braid index.) The permutation is returned in one-line 
    notation (not cycle notation).
    """
    if stopping_index == -1:
        stopping_index = len(braid)
    permutation = [jjj+1 for jjj in range(index)]
    for jjj in range(stopping_index):
        crossing = np.abs(braid[jjj])
        temp = permutation[crossing-1]
        permutation[crossing-1] = permutation[crossing]
        permutation[crossing] = temp
    return permutation


def permutation_cycle_test(braid,index,stopping_index = -1):
    """
    Similar to the above function permutation_test, except that the answer is returned as a list of disjoint cycles
    representing the braid permutation.
    """
    # List of strands not checked.
    not_visited = [jjj for jjj in range(1,index+1)]
    # List of strands checked.
    visited = []
    # List to collect disjoint cycles representing the braid permutation.
    permutation_cycle = []
    # One line notation representing the braid permutation.
    permutation_list = permutation_test(braid,index,stopping_index)
    while len(not_visited) > 0:
        # Pick a strand we haven't visited yet, and start building up it's cycle.
        starting_strand = not_visited[0]
        jjj = starting_strand
        permutation_sub_cycle = [jjj]
        next_strand = permutation_list.index(jjj)+1
        visited.append(jjj)
        not_visited.remove(jjj)
        # Cycle through the permutation, adding strands to the cycle until you reach the starting strand again.
        while next_strand != starting_strand:
            jjj = next_strand
            next_strand = permutation_list.index(jjj)+1
            permutation_sub_cycle.append(jjj)
            visited.append(jjj)
            not_visited.remove(jjj)
        permutation_cycle.append(permutation_sub_cycle)
    return permutation_cycle  


def permutation_cycle_from_transpositions(transposition_list,index):
    """
    Takes a list of transpositions and returns the associated permutation written in dijoint cycle notation.
    """
    # Temporary braid to build up the permutation.
    permutation_braid = []
    for jjj in range(len(transposition_list)):
        transposition_list[jjj].sort()
        transposition = transposition_list[jjj]
        # Create a band connecting the two strands involved in the permutation, and add it to the temporary braid.
        band = [jjj for jjj in range(transposition[0],transposition[1])]+[-jjj for jjj in range(transposition[1]-2,transposition[0]-1,-1)]
        permutation_braid = permutation_braid+band
    # Return the braid permutation of the temporary braid.
    return permutation_cycle_test(permutation_braid,index)


def insert_random_band(braid,index,start,end,band_sign,conjugate_length_st_dev = 0.8,sgr_st_dev = 0.6):
    """
    Insert a random band into a given braid, with a given sign, at a random point in the braid word, connecting 
    strand numbers start and end (labeled in relation to their positions at the beginning of the braid word).
    """
    global log
    # If start strand number is greater than the end strand number, swap the two values.
    if start > end:
        temp = start
        start = end
        end = temp
    # Select the position in the braid word to insert the new band.
    position = np.random.choice([jjj for jjj in range(len(braid)+1)])
    # Find the braid permutation up to the position where the band will be inserted.
    permutation = permutation_test(braid,index,position)
    # Determine the new start and end strand numbers (based on the partial permutation found above).
    new_start = permutation.index(start)+1
    new_end = permutation.index(end)+1
    # Construct a random band with specified start and end strands, and add it to the braid.
    band = random_band(index,new_start,new_end,band_sign,conjugate_length_st_dev,sgr_st_dev)
    braid[position:position] = band
    #log = log+"Inserted band "+str(band)+" at position "+str(position)+"\n"
    #log = log+str(braid)+"\n"
    return braid


def band_permutation_connectivity(index,band_count,braid = []):
    """
    Returns a random list of -1 and 1, which can be interpreted as a sequence of merging bands (-1) and splitting 
    bands (+1) to be added to a braid to ensure the closure of the final result is connected (a knot).  The argument
    band_count specifies how long this list is.
    """
    position = len(permutation_cycle_test(braid,index))
    # If the parity of band_cound is not correct (meaning the resulting braid will never yield a knot) add 1 to the
    # band_count.
    if (position-1)%2 != band_count%2:
        band_count = band_count+1
    ## If the number of bands specificed is not enough to yeild a braid with connected closure, return an error 
    ## message.
    #if (index-1)<band_count:
    #    print("Error: not enough bands specified to yeild a braid with connected closure.")
    #    return
    band_connection_list = []
    # Determine the number of bands that will split a given component into two.
    split_bands = (band_count-(position-1))//2
    # Determine the number of bands that will merge two components into one.
    merge_bands = band_count-split_bands
    # Arrange a list of -1s and 1s in a way so that you never have more than index number of components, or less
    # than one component.
    for jjj in range(band_count):
        if position == index or split_bands == 0:
            band_connection_list.append(-1)
            position = position-1
            merge_bands = merge_bands-1
        elif position == 1 or merge_bands == 0:
            band_connection_list.append(1)
            position = position+1
            split_bands = split_bands-1
        elif np.random.choice([0,1]) == 0:
            band_connection_list.append(1)
            position = position+1
            split_bands = split_bands-1
        else:
            band_connection_list.append(-1)
            position = position-1
            merge_bands = merge_bands-1
    return band_connection_list


def simplify_R2(braid,starting_position = 0,remove_all = False):
    """
    Scans the braid word, starting at the specified position, and removes neigboring pairs of canceling crossings.
    If the option remove_all is True it will remove all such pairs; if not, it only removes the first one it 
    encounters.
    """
    global log
    new_braid = braid.copy()
    old_braid = []
    position = starting_position
    # Perform the search and remove as long as the previous step returned a different braid than it started with.
    while new_braid != old_braid:
        old_braid = new_braid.copy()
        # Begin scanning the braid word, starting at the specified position.
        jjj = 0
        while jjj<len(new_braid):
            # If a cancelling pair is located, remove it.
            if new_braid[(position+jjj)%len(new_braid)] == -new_braid[(position+jjj+1)%len(new_braid)]:
                smaller_index = min((position+jjj)%len(new_braid),(position+jjj+1)%len(new_braid))
                larger_index = max((position+jjj)%len(new_braid),(position+jjj+1)%len(new_braid))
                new_braid.pop(larger_index)
                new_braid.pop(smaller_index) 
                #log = log+"Removed R2 canceling pair at position "+str((position+jjj)%len(new_braid))+"\n"
                #log = log+str(new_braid)+"\n"
                # If remove_all is set to False stop after one such removal, otherwise continue until no such 
                # cancelling pairs remain.
                if not remove_all:
                    return new_braid
            jjj = jjj+1
    return new_braid



def add_random_R2(braid,index):
    """
    Add a random pair of cancelling crossings somewhere in the braid word.
    """
    global log
    new_braid = braid.copy()
    # Specify the location and index of the new crossing to be added.
    location = np.random.choice(len(braid)+2)
    crossing = np.random.choice([jjj for jjj in range(1,index)])
    # Select a random sign for the pair of crossings.
    sign = np.random.choice([-1,1])
    # If the location is selected at the end of the word, add one of the crossings at the end and the other at the
    # beginning.
    if location == len(braid)+1:
        new_braid[location:location] = [sign*crossing]
        new_braid[0:0] = [-sign*crossing]
        #log = log+"Added R2 canceling pair at position "+str(location)+"\n"
        #log = log+str(braid)+"\n"
    # Otherwise, add both at the specified location.
    else:
        new_braid[location:location] = [sign*crossing,-sign*crossing]
        #log = log+"Added R2 canceling pair at position "+str(location)+"\n"
        #log = log+str(braid)+"\n"
    return new_braid



def random_cut(braid):
    """
    Split the braid word at a random point, and concatenate the two pieces in reverse order.
    """
    global log
    new_braid = braid.copy()
    location = np.random.choice(len(braid))
    new_braid = new_braid[location:]+new_braid[:location]
    #log = log+"Cut braid at position "+str(location)+"\n"
    #log = log+str(braid)+"\n"
    return new_braid


def apply_R3(braid,starting_position = 0):
    """
    Scan through the braid word, starting at the specified starting position, find the first place that an R3 braid
    relation can be applied, and apply it.
    """
    global log
    new_braid = braid.copy()
    position = starting_position
    for iii in range(len(braid)):
        loc1 = (iii+position)%len(new_braid)
        loc2 = (iii+position+1)%len(new_braid)
        loc3 = (iii+position+2)%len(new_braid)
        if new_braid[loc1] == new_braid[loc3] and np.abs(new_braid[loc1]-new_braid[loc2]) == 1:
            letter1 = new_braid[loc1]
            letter2 = new_braid[loc2]
            new_braid[loc1] = letter2
            new_braid[loc3] = letter2
            new_braid[loc2] = letter1
            #log = log+"Applied R3 move at location "+str(loc1)+"\n"
            #log = log+str(new_braid)+"\n"
        elif new_braid[loc1] == -new_braid[loc3] and np.abs(np.abs(new_braid[loc1])-np.abs(new_braid[loc2])) == 1:
            letter1 = new_braid[loc1]
            letter2 = new_braid[loc2]
            letter3 = new_braid[loc3]
            sign = np.sign(letter1)*np.sign(letter2)
            new_braid[loc1] = np.abs(letter2)*np.sign(letter3)
            new_braid[loc2] = sign*letter1
            new_braid[loc3] = sign*letter2
            #log = log+"Applied R3 move at location "+str(loc1)+"\n"
            #log = log+str(new_braid)+"\n"
    return new_braid


def braid_word_to_string(braid,index):
    """
    Converts a braid word into a braid string, with crossing 1 corresponding to A, crossings -1 corresponding to a,
    etc.  
    
    Note: The maximal braid index allowable is 26.
    """
    capitals = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    lowercases = "abcdefghijklmnopqrstuvwxyz"
    let = {}
    for jjj in range(index):
        let[1+jjj] = capitals[jjj]
        let[-1-jjj] = lowercases[jjj]
    L = [let[jjj] for jjj in braid]
    braid_string = ""
    for jjj in L:
        braid_string = braid_string+jjj
    return braid_string



def remove_min_R1(braid):
    """
    Check the braid word for any R1 moves that can be removed on the left of the braid, and if so, remove them. 
    
    Note: Removing such R1 'kinks' is necessary for producing correct answers in software like KnotJob and the 
    Mathematica KnotTheory package.
    """
    global log
    b = np.copy(braid)
    oldLength = len(b)
    newLength = 0
    while oldLength > newLength:
        oldLength = len(b)
        if len(b) == 0:
            return b
        # Check if the minimal crossing that appears is unique (i.e. if it only shows up once in the braid word).
        # If so, there is an R1 move that can be removed.
        if len(np.where(np.abs(b) == min(np.abs(b)))[0]) == 1:
            location = np.where(np.abs(b) == min(np.abs(b)))[0][0]
            b = np.delete(b,location)
            # For all remaining crossings in the braid word, adjust them to account for the deleted R1 move.
            for jjj in range(len(b)):
                b[jjj] = b[jjj]-np.sign(b[jjj])
            #log = log+"Removed a minimum R1 crossing at location "+str(location)+"\n"
            #log = log+str(b)+"\n"
        newLength = len(b)
    return b



def remove_max_R1(braid):
    """
    Similar to the function above, this searches for R1 moves (Markov stabilizations) that can be removed on the 
    right side of the braid.
    """
    global log
    b = np.copy(braid)
    oldLength = len(b)
    newLength = 0
    while oldLength > newLength:
        oldLength = len(b)
        if len(b) == 0:
            return b
        if len(np.where(np.abs(b) == max(np.abs(b)))[0]) == 1:
            location = np.where(np.abs(b) == max(np.abs(b)))[0][0]
            b = np.delete(b,location)
            #log = log+"Removed a maximum R1 crossing at location "+str(location)+"\n"
            #log = log+str(b)+"\n"
        newLength = len(b)
    return b



def remove_R2(braid):
    """
    Scans through the braid and removes all pairs of cancelling adjacent crossings.  This should be equivalent to
    the simplify_R2 function with the remove_all option set to True.  Not sure why I coded it up twice.
    """
    global log
    b = np.copy(braid)
    oldLength = len(b)
    newLength = 0
    while oldLength > newLength and len(b) > 0:
        oldLength = len(b)
        if b[oldLength-1] == -b[0]:
            b = np.delete(b,np.array([oldLength-1]))
            b = np.delete(b,np.array([0]))
            #log = log+"Removed R2 canceling pair at position "+str(oldLength-1)+"\n"
            #log = log+str(b)+"\n"
        jjj = 0
        while jjj<len(b)-1:
            if b[jjj] == -b[jjj+1]:
                b = np.delete(b,np.array([jjj,jjj+1]))
                #log = log+"Removed R2 canceling pair at position "+str(jjj)+"\n"
                #log = log+str(b)+"\n"
            else:
                jjj += 1
        newLength = len(b)
    return b



def simplify_braid(braid):
    """
    Applies the above functions repeatedly to try to remove all cancelling crossing pairs and R1 moves, to shorten
    the braid word as much as possible.
    """
    b = np.copy(braid)
    oldLength = len(b)
    newLength = 0
    while oldLength > newLength:
        oldLength = len(b)
        b = remove_R2(b)
        b = remove_min_R1(b)
        b = remove_max_R1(b)
        b = remove_R2(b)
        newLength = len(b)
    return list(b)



def complicate_braid(braid,index,move_count = 100):
    """
    Randomly applies Reidemeister moves to a braid word to obfuscate its band structure.
    """
    b = list(np.copy(braid))
    for iii in range(move_count):
        if len(b) == 0:
            return b
        move = np.random.choice(4)
        if move == 0:
            c = random_cut(b)
        if move == 1:
            c = apply_R3(b,np.random.choice(len(b)))
        if move == 2:
            c = add_random_R2(b,index)
        if move == 3:
            c = simplify_R2(b,np.random.choice(len(b)))
        if len(permutation_cycle_test(c,index)) > 1:
          print(b,c,move)
        b = c
    return b


def random_line(afile):
    line  =  next(afile)
    for num, aline in enumerate(afile, 2):
        if random.randrange(num):
            continue
        line  =  aline
    return line


SliceFile  =  "SliceSeedBraids.csv"
NonSliceFile  =  "NonSliceSeedBraids.csv"


def pull_seed_braid(slice_knot = "maybe"):
    """
    Opens a file from KnotInfo corresponding to slice or nonslice knots, and return a braid representative for a 
    knot along with the lower and upper bounds on the slice Euler characteristic.
    """
    global log
    if slice_knot == True:
        file = SliceFile
    elif slice_knot == False:
        file = NonSliceFile
    else:
        file = np.random.choice([SliceFile,NonSliceFile])
    # Open the file.
    a = random.choice(open(file, mode = 'r', encoding = 'utf-8-sig').readlines())
    # Replace string separating characters with "W", which will be replaced at the next step.
    b = a.replace('],[','W').replace(']","','W').replace(']",','W').replace('[','').replace(']','').replace('\n','').replace('"','')
    b = b.split("W")
    # Converting all string integers to ints.
    c = [[int(iii) for iii in jjj.split(",")] for jjj in b]
    genus = c.pop()
    euler_char_lower = 1-2*max(genus)
    euler_char_upper = 1-2*min(genus)
    loc = np.random.choice(len(c))
    braid = c[loc]
    index = max(np.abs(braid))+1
    #log = log+"Pulled the seed braid "+str(braid)+" with euler characteristic lower bound "+str(euler_char_lower)+" and euler characteristic upper bound "+str(euler_char_upper)+"\n"
    #log = log+str(braid)+"\n"
    return braid,index,euler_char_lower,euler_char_upper


def add_cobordism_bands(input_braid,index,cobordism_negative_bands,cobordism_positive_bands,band_connectivity_list,conjugate_length_st_dev = 1,sgr_st_dev = 0.6):
    """
    Adds cobordism bands to a given braid (i.e. bands to the existing braid, without increasing the number of 
    braid strands).  The signs of the bands are determined by the values of cobordism_negative_bands, and 
    cobordism_positive_bands, while the connectivity is determined by the band_connectivity_list.
    """
    # Compile a list of cobordism bands, and randomize their signs (keeping the number of each sign fixed).
    cobordism_bands = cobordism_negative_bands+cobordism_positive_bands
    cobordism_signs = [1 for jjj in range(cobordism_positive_bands)]+[-1 for jjj in range(cobordism_negative_bands)]
    np.random.shuffle(cobordism_signs)
    braid = input_braid.copy()
    permutation = permutation_cycle_test(braid,index)
    for jjj in range(cobordism_bands):
        # If element of band_connectivity_list indicates a merging band should be added, select two cycles
        # of the braid permutation, and select one strand from each cycle, before inserting a band of the 
        # correct sign at the chosen endpoints.
        if band_connectivity_list[jjj] == -1:
            m,n = np.random.choice(len(permutation),2,replace = False)
            start_strand = np.random.choice(permutation[m])
            end_strand = np.random.choice(permutation[n])
            braid = insert_random_band(braid,index,start_strand,end_strand,cobordism_signs[jjj],conjugate_length_st_dev,sgr_st_dev)
        # If element of band_connectivity_list indicates a splitting band should be added, create a list of 
        # all cycles in the braid permutation which involve more than one strand, then select one such cycle
        # and two strands from it.  Finally, insert a band of the correct sign at the chosen endpoints.
        if band_connectivity_list[jjj] == 1:
            long_cycles = permutation.copy()
            for iii in permutation:
                if len(iii)<2:
                    long_cycles.remove(iii)
            n = np.random.choice(len(long_cycles))
            start_strand,end_strand = np.random.choice(long_cycles[n],2,replace = False)
            braid = insert_random_band(braid,index,start_strand,end_strand,cobordism_signs[jjj],conjugate_length_st_dev,sgr_st_dev)
        permutation = permutation_cycle_test(braid,index)
    return braid,index,band_connectivity_list[cobordism_bands:]


def add_markov_bands(input_braid,index,markov_negative_bands,markov_positive_bands,conjugate_length_st_dev = 1,sgr_st_dev = 0.6):
    """
    Adds Markov bands to a given braid (i.e. bands connecting the existing braid to a new unknotted strand.  The 
    signs of the bands are determined by the values of markov_negative_bands, and markov_positive_bands.
    """
    braid = input_braid.copy()
    # Select the locations of where to insert the strands that will be used for the Markov bands.
    markov_positions = np.sort(np.random.choice([jjj for jjj in range(1,index+1+markov_positive_bands+markov_negative_bands)],markov_positive_bands+markov_negative_bands,replace = False))
    # Insert the new strands for the Markov bands.
    for jjj in markov_positions:
        braid = insert_strand(braid,index,jjj,np.random.choice([-1,1]))
        index = index+1
    np.random.shuffle(markov_positions)
    # Randomize the signs of the Markov bands (keeping the number of each sign fixed).
    markov_signs = [1 for jjj in range(markov_positive_bands)]+[-1 for jjj in range(markov_negative_bands)]
    np.random.shuffle(markov_signs)
    # Insert bands to complete Markov bands.
    for jjj in range(len(markov_positions)):
        permutation = permutation_cycle_test(braid,index)
        possible_end_components = []
        # Cycling through each new Markov strand, look at each cycle in the braid permutation and check 
        # whether it contains the Markov strand of interest.  If not, then add it to the list of possible
        # end components for a band connecting to the given Markov strand.
        for iii in permutation:
            if markov_positions[jjj] not in iii:
                possible_end_components.append(iii)
        # At random select one of the possible end components from the list compiled above.
        m = np.random.choice(len(possible_end_components))
        end_component = possible_end_components[m]
        # Select a strand from the end component selected above, and insert a random band with the sign 
        # determined above.
        end_strand = np.random.choice(end_component)
        braid = insert_random_band(braid,index,markov_positions[jjj],end_strand,markov_signs[jjj],conjugate_length_st_dev,sgr_st_dev)
    return braid,index


def initial_quasipositive_braid(quasipositive_bands,index,band_connectivity_list,conjugate_length_st_dev = 1,sgr_st_dev = 0.6,seed_sign = "randomize"):
    """
    Produce a random quasipositive or quasinegative braid with the number of initial bands determined by 
    the value of quasipositive_bands.
    """
    braid = []
    if seed_sign == "randomize":
        random_sign_exponent = 1
        seed_sign = 1
    else:
        random_sign_exponent = 0
    permutation = permutation_cycle_test(braid,index)
    # Build the initial braid by adding quasipositive_bands number of bands to the empty braid.
    for jjj in range(quasipositive_bands):
        # If the entry in the band_connectivity_list is -1 add a band which merges two components.
        if band_connectivity_list[jjj] == -1:
            # Select two disjoint subcycles to merge from the permutation cycle description.
            m,n = np.random.choice(len(permutation),2,replace = False)
            # From each of the two subcycles selected, pick a strand.  One will be the start strand for the 
            # band while the other will be the end strand.
            start_strand = np.random.choice(permutation[m])
            end_strand = np.random.choice(permutation[n])
            braid = insert_random_band(braid,index,start_strand,end_strand,(np.random.choice([-1,1])**random_sign_exponent)*seed_sign,conjugate_length_st_dev,sgr_st_dev)
        # If the entry in the band_connectivity_list is 1 add a band which splits one component into two.
        if band_connectivity_list[jjj] == 1:
            # Create a list of subcycles of length at least two which can be split.
            long_cycles = permutation.copy()
            for jjj in permutation:
                if len(jjj)<2:
                    long_cycles.remove(jjj)
            # Select a cycle to split, and a start strand and end strand from that cycle where the band will 
            # be placed.
            n = np.random.choice(len(long_cycles))
            start_strand,end_strand = np.random.choice(long_cycles[n],2,replace = False)
            braid = insert_random_band(braid,index,start_strand,end_strand,(np.random.choice([-1,1])**random_sign_exponent)*seed_sign,conjugate_length_st_dev,sgr_st_dev)
        # Rebuild the braid permutation cycle list.
        permutation = permutation_cycle_test(braid,index)
    return braid,index,band_connectivity_list[quasipositive_bands:]



def random_braid(seed_braid = "maybe", slice_knot = "maybe", max_initial_index = 5, max_total_bands = 8, conjugate_length_st_dev = 0.5, sgr_st_dev = 0.5, seed_sign = 0, fix_index = False, fix_original_band_count = False, fix_original_band_choices = False):    
    """
    Creates a random braid. 
    """
    global log
    assert max_initial_index-1 <=  max_total_bands, "The max initial index must be no greater than the max number of total bands plus 1." 
    if seed_braid == "maybe":
        seed_braid = np.random.choice([True,False])
    if slice_knot == "maybe":
        slice_knot = np.random.choice([True,False])
    if seed_sign == 0:
        seed_sign = np.random.choice([-1,1])
    if not seed_braid:
        ######print("A")
        ######print(slice_knot)
        # Select an initial index.
        if fix_original_band_choices:
            fix_index = True
            fix_original_band_count = True
        if fix_index:
            index = max_initial_index
        else:
            index = np.random.choice(np.arange(2,max_initial_index+1))
        if fix_original_band_count:
            total_bands = max_total_bands
        else:
            total_bands = np.random.choice(np.arange(index-1,max_total_bands+1))
        if slice_knot:
            quasipositive_bands = index-1
            markov_bands = 0
            cobordism_bands = 0
            seed_sign = "randomize"
        else:
            quasipositive_bands = np.random.choice(total_bands+1)
            cobordism_bands = np.random.choice(np.arange(max(0,index-1-quasipositive_bands),total_bands-quasipositive_bands+1))
            markov_bands = total_bands-quasipositive_bands-cobordism_bands
            seed_sign = np.random.choice([-1,1])
        # Check to ensure the parity of the total number of bands is correct to achieve a knot. Should never 
        # be triggered if slice_knot is true.
        if (cobordism_bands+quasipositive_bands)%2 == (index)%2:
            if np.random.choice([True,False]):
                quasipositive_bands = quasipositive_bands+np.random.choice([-1,1])
                if quasipositive_bands == -1:
                    quasipositive_bands = 1
            else:
                cobordism_bands = cobordism_bands+np.random.choice([-1,1])
                if cobordism_bands == -1:
                    cobordism_bands = 1
        markov_positive_bands = np.random.choice(markov_bands+1)
        markov_negative_bands = markov_bands-markov_positive_bands   
        cobordism_positive_bands = np.random.choice(cobordism_bands+1)
        cobordism_negative_bands = cobordism_bands-cobordism_positive_bands
        quasipositive_band_connectivity_list = band_permutation_connectivity(index,quasipositive_bands+cobordism_bands)
        braid,index,band_connectivity_list = initial_quasipositive_braid(quasipositive_bands,index,quasipositive_band_connectivity_list,conjugate_length_st_dev,sgr_st_dev,seed_sign)
        euler_char_lower_bound = index-quasipositive_bands-cobordism_bands
        euler_char_upper_bound = min(1,index-quasipositive_bands+cobordism_bands)   
    elif seed_braid:
        ######print("B")
        # Pull a seed braid from one of the lists.
        braid,index,euler_char_lower_bound,euler_char_upper_bound = pull_seed_braid(slice_knot)
        # This gives an estimate of the number of initial bands needed to construct the seed braid.  
        ######quasipositive_bands = index-euler_char_upper_bound
        total_bands = np.random.choice(np.arange(index-1,max_total_bands+1))
        quasipositive_bands = np.random.choice(total_bands+1)
        if slice_knot:
            markov_bands = total_bands-quasipositive_bands
        else:
            markov_bands = np.random.choice(total_bands-quasipositive_bands+1)
        # The following cobordism band count will be zero is slice_knot is True.
        cobordism_bands = total_bands-quasipositive_bands-markov_bands
        # Check to ensure the parity of the total number of bands is correct to achieve a knot. Should never 
        # be triggered if slice_knot is true.
        if cobordism_bands%2 == 1:
            cobordism_bands = cobordism_bands+np.random.choice([-1,1]) 
        markov_positive_bands = np.random.choice(markov_bands+1)
        markov_negative_bands = markov_bands-markov_positive_bands   
        cobordism_positive_bands = np.random.choice(cobordism_bands+1)
        cobordism_negative_bands = cobordism_bands-cobordism_positive_bands
        band_connectivity_list = band_permutation_connectivity(index,cobordism_bands,braid)
        euler_char_lower_bound = euler_char_lower_bound-cobordism_bands
        euler_char_upper_bound = min(1,euler_char_upper_bound+cobordism_bands)
    permutation = permutation_cycle_test(braid,index)
    # Add Markov bands to the braid.
    braid,index = add_markov_bands(braid,index,markov_negative_bands,markov_positive_bands,conjugate_length_st_dev,sgr_st_dev)
    # Add cobordism bands to the braid.
    braid,index,band_connectivity_list = add_cobordism_bands(braid,index,cobordism_negative_bands,cobordism_positive_bands,band_connectivity_list,conjugate_length_st_dev,sgr_st_dev)
    """
    Old bit of code that manually complicates the braid.  It has now been replaced by a separate function.
    # Select a random number of R3 moves to apply to the resulting braid, then for each one select a random
    # location in the braid and apply the move.
    for lll in range(np.random.choice(range(len(braid)//4+1))):
        k = np.random.choice(len(braid))
        braid = apply_R3(braid,k)
    # Remove all cancelling pairs via R2 moves.
    braid = simplify_R2(braid,remove_all = True)
    # Repeat the proceedure of applying R3 moves randomly.
    for lll in range(np.random.choice(range(len(braid)//4+1))):
        k = np.random.choice(len(braid))
        braid = apply_R3(braid,k)
    # Remove any new R2 moves that were introduced.
    braid = simplify_R2(braid,remove_all = True)
    # Randomly cut the braid.
    braid = random_cut(braid)
    """
    complicated_braid = complicate_braid(braid,index)
    # Convert a simplified version of the braid to a string for use in KnotJob.
    simplified_braid = simplify_braid(braid)
    braid_string = braid_word_to_string(simplified_braid,index)
    #log = log+"Final braid "+str(braid)+"\n"
    #log = log+"Complicated braid "+str(complicated_braid)+"\n"
    #log = log+"Simplified braid "+str(simplified_braid)+"\n"
    #log = log+"Braid string "+braid_string+"\n"
    return braid, complicated_braid, simplified_braid, braid_string, index, euler_char_lower_bound, euler_char_upper_bound

def bounded_random_braid(bound = 30, seed_braid = "maybe", slice_knot = "maybe", max_initial_index = 5, max_total_bands = 8, conjugate_length_st_dev = 0.5, sgr_st_dev = 0.5, seed_sign = 0, fix_index = False, fix_original_band_count = False, fix_original_band_choices = False):
    global log
    #log = ""
    current_length = bound+1
    while current_length > bound:
        braid,complicated_braid,simplified_braid,braid_string,index,euler_char_lower_bound,euler_char_upper_bound = random_braid(seed_braid, 
                                                                                                                                 slice_knot, 
                                                                                                                                 max_initial_index, 
                                                                                                                                 max_total_bands, 
                                                                                                                                 conjugate_length_st_dev, 
                                                                                                                                 sgr_st_dev, 
                                                                                                                                 seed_sign, 
                                                                                                                                 fix_index, 
                                                                                                                                 fix_original_band_count, 
                                                                                                                                 fix_original_band_choices)
        current_length = len(complicated_braid)
    return braid, complicated_braid, simplified_braid, braid_string, index, euler_char_lower_bound, euler_char_upper_bound

"""### Slice Environment"""

import gym
from gym import spaces
import numpy as np
from gym.utils import seeding




class SliceEnv_v2(gym.Env):
    """An OpenAI Gym environment for builing minimal genus slice surfaces."""
    metadata = {'render.modes': ['human']}
    
    def __init__(self, config = {}):
        
   
        # This is the bonus that is given to the score whenever an unlinked component is created.
        if "bonus" in config:
            self.bonus = config["bonus"]
        else: 
            self.bonus = 0
            
            
        # The penalty given for any action which results in a reward of 0 (should be a positive value).
        if "inaction_penalty" in config:
            self.inaction_penalty = config["inaction_penalty"]
        else: 
            self.inaction_penalty = 0.05

        
        # The maximum length a braid word can be, which is fixed once the environment is instantiated. 
        if "max_braid_length" in config:
            self.max_braid_length = config["max_braid_length"]
        else: 
            self.max_braid_length = 50
        
        
        # The penalty given at the end of any episode that doesn't result in a trivialized braid.
        if "final_penalty" in config:
            self.final_penalty = config["final_penalty"]
        else: 
            self.final_penalty = 2*self.max_braid_length  

        
        # The maximum number of actions in an episode.
        if "max_action_count" in config:
            self.max_actions = config["max_action_count"]
        else: 
            self.max_actions = 400


        # A counter that is used to create new labels for components that are introduced when new strands are added 
        # (following the removal of unlinked strands on the knot component).
        self.extra_strands = 0    
        
        
        if "starting_knot_strand" in config:
            self.starting_knot_strand = config["starting_knot_strand"]
        else: 
            self.starting_knot_strand = 1 
 
        
        # The starting braid word.
        if "starting_word" in config:
            self.starting_braid = config["starting_word"]
        else:
            self.starting_braid = "random"

            
        # The maximum number of strands that can be used in the braid at any given time.
        if "max_possible_braid_index" in config:
            self.max_possible_index = config["max_possible_braid_index"]
        else: 
            self.max_possible_index = 15  


        if "max_initial_braid_lengths" in config: 
            self.max_initial_braid_lengths = config["max_initial_braid_lengths"]
        else:
            self.max_initial_braid_lengths = [self.max_braid_length//2]


        if "initial_braid_indices" in config: 
            self.initial_braid_indices = config["initial_braid_indices"]
        else:
            self.initial_braid_indices = [self.max_possible_index//2]


        if "initial_band_counts" in config: 
            self.initial_band_counts = config["initial_band_counts"]
        else:
            self.initial_band_counts = [3]
        

        # Mode controls the type of braids considered.  In simple_ribbon mode, the index of the braid is fixed
        # at the beginning, and no new strands can be added.  All strands belong to the same component.
        if "mode" in config:
            self.mode = config["mode"]
        else:
            self.mode = "simple_ribbon_train"


        if "train_on_slice_knots" in config:
            self.train_on_slice_knots = config["train_on_slice_knots"]
        else: 
            self.train_on_slice_knots = False 

        
        if "slice_bonus" in config:
            self.reward_slice = True
            self.slice_bonus = config["train_on_slice_knots"]
        else: 
            self.reward_slice = False 

          
        if "length_parameter" in config:
            self.length_parameter = config["length_parameter"]
        else:
            self.length_parameter = 0.0000001

          
        if "index_parameter" in config:
            self.index_parameter = config["index_parameter"]
        else:
            self.index_parameter = 0.0000001

          
        if "band_parameter" in config:
            self.band_parameter = config["band_parameter"]
        else:
            self.band_parameter = 0.0000001

        
        if self.mode == "simple_ribbon_train" and self.starting_braid == "random":
            self.max_possible_index = max(self.initial_braid_indices)
            self.max_possible_initial_braid_length = max(self.max_initial_braid_lengths)
            self.max_possible_initial_band_count = max(self.initial_band_counts)
            self.low_bound = np.array([-self.max_possible_index+1 for jjj in range(self.max_braid_length)]+[0,1])
            self.high_bound = np.array([self.max_possible_index-1 for jjj in range(self.max_braid_length)]+[self.max_braid_length,self.max_possible_index])
            self.min_index_parameter = min(self.initial_braid_indices)
            self.min_length_parameter = min(self.max_initial_braid_lengths)
            self.min_band_parameter = min(self.initial_band_counts)
            self.initial_index = min(self.initial_braid_indices)
            self.current_index = self.initial_index
            self.max_initial_braid_length = min(self.max_initial_braid_lengths)
            self.initial_band_count = min(self.initial_band_counts)
            self.entire_braid = bounded_random_braid(bound = self.max_initial_braid_length, 
                                                          max_initial_index = self.initial_index,
                                                          max_total_bands = self.initial_band_count,
                                                          seed_braid = False, 
                                                          slice_knot = self.train_on_slice_knots, 
                                                          fix_original_band_choices = True)
            self.starting_word = self.entire_braid[1]
        elif self.mode == "simple_ribbon_test" and self.starting_braid == "random":
            self.max_possible_index = max(self.initial_braid_indices)
            self.max_possible_initial_braid_length = max(self.max_initial_braid_lengths)
            self.max_possible_initial_band_count = max(self.initial_band_counts)
            self.low_bound = np.array([-self.max_possible_index+1 for jjj in range(self.max_braid_length)]+[0,1])
            self.high_bound = np.array([self.max_possible_index-1 for jjj in range(self.max_braid_length)]+[self.max_braid_length,self.max_possible_index])
            self.min_index_parameter = min(self.initial_braid_indices)
            self.min_length_parameter = min(self.max_initial_braid_lengths)
            self.min_band_parameter = min(self.initial_band_counts)
            self.initial_index = np.random.choice(np.arange(self.min_index_parameter, self.max_possible_index+1, dtype = int))
            self.current_index = self.initial_index
            self.max_initial_braid_length = np.random.choice(np.arange(self.min_length_parameter, self.max_possible_initial_braid_length+1, dtype = int))
            self.initial_band_count = np.random.choice(np.arange(self.min_band_parameter, self.max_possible_initial_band_count+1, dtype = int))
            self.initial_band_count = max(self.initial_band_count, self.initial_index-1)
            self.entire_braid = bounded_random_braid(bound = self.max_initial_braid_length, 
                                                          max_initial_index = self.initial_index,
                                                          max_total_bands = self.initial_band_count,
                                                          seed_braid = False, 
                                                          slice_knot = self.train_on_slice_knots, 
                                                          fix_original_band_choices = True)
            self.starting_word = self.entire_braid[1]
        elif self.mode == "simple_ribbon_train" and self.starting_braid != "random":
            self.starting_word = list(self.starting_braid)
            self.initial_index = max(np.abs(self.starting_word))+1
            self.current_index = self.initial_index
            self.max_possible_index = max(self.initial_braid_indices)
            self.low_bound = np.array([-self.max_possible_index+1 for jjj in range(self.max_braid_length)]+[0,1])
            self.high_bound = np.array([self.max_possible_index-1 for jjj in range(self.max_braid_length)]+[self.max_braid_length,self.max_possible_index])
        elif self.mode == "simple_ribbon_test" and self.starting_braid != "random":
            self.starting_word = list(self.starting_braid)
            self.initial_index = max(np.abs(self.starting_word))+1
            self.current_index = self.initial_index
            self.max_possible_index = max(self.initial_braid_indices)
            self.low_bound = np.array([-self.max_possible_index+1 for jjj in range(self.max_braid_length)]+[0,1])
            self.high_bound = np.array([self.max_possible_index-1 for jjj in range(self.max_braid_length)]+[self.max_braid_length,self.max_possible_index])
        elif self.mode != "simple_ribbon_train" or self.mode != "simple_ribbon_test":
            self.low_bound = np.array([-self.max_possible_index+1 for jjj in range(self.max_braid_length)]+[0,1]+[1 for jjj in range(self.max_possible_index)]+[-np.inf for jjj in range(self.max_possible_index)])
            self.high_bound = np.array([self.max_possible_index-1 for jjj in range(self.max_braid_length)]+[self.max_braid_length,self.max_possible_index]+[self.max_possible_index for jjj in range(self.max_possible_index)]+[1 for jjj in range(self.max_possible_index)])
        
            # TODO: decide what to do here.
        
        
        # The numpy array that tracks the braid word representing the knot.
        self.word = np.array(self.starting_word) 
        assert len(self.word)  <=  self.max_braid_length, "Cannot initialize with braid with length longer than max_braid_length"
        
        self.episode_count = 0
        # This list should have one entry for each strand in the braid word (self.max_possible_index number of them), and tracks 
        # which strands are on the same component.  
        # For example, if the list is [1,1,2,3,3] it means the first two strands belong to component number 1 of the 
        # surface created, the third strand belongs to component number 2, while the last two strands again belong to 
        # the same component, component number 3.
        self.components = np.zeros(self.max_possible_index,int)  
        self.component_count = 1
        # This assigns the component of starting_knot_strand the number 1.
        self.components[self.starting_knot_strand-1] = self.component_count
        self.temp_position = len(self.word)
        # Starting with the starting_knot_strand, we trace it back through the braid word to see what other strands it 
        # connects to.
        self.next_strand = self.traceback(self.temp_position,self.starting_knot_strand)[0]
        # Label the next strand on the same component as component number 1, and assign it an Euler characteristic of 0.
        self.components[self.next_strand-1] = self.component_count
        self.eulerchar = {1:0}
        # Iterate through the rest of the strands of the knot component, assigning them component number 1.
        while self.next_strand != self.starting_knot_strand:
            self.next_strand = self.traceback(self.temp_position,self.next_strand)[0]
            self.components[self.next_strand-1] = self.component_count
        # Iterate now through the remaining strands, assigning increasing values for each subsequent component.
        for jjj in range(self.max_possible_index):
            if self.components[jjj] == 0:
                self.component_count += 1
                self.new_starting_knot_strand = jjj+1
                self.components[self.new_starting_knot_strand-1] = self.component_count
                self.next_strand = self.traceback(self.temp_position,self.new_starting_knot_strand)[0]
                self.components[self.next_strand-1] = self.component_count
                while self.next_strand != self.new_starting_knot_strand:
                    self.next_strand = self.traceback(self.temp_position,self.next_strand)[0]
                    self.components[self.next_strand-1] = self.component_count   
        # Assign an euler characteristic of 1 to any components other than the knot component.
        for key in self.components:
            if key != 1:
                self.eulerchar[key] = 1
        # Initiate the score to 0.
        self.score = 0
        # Initiate the cursor position.
        self.cursor = np.array([0,1])
        # Run through the different strands.  If any strands corresponding to component number 1 are unlinked, delete them.
        for jjj in range(self.current_index):
            self.unlinked_strand_check(jjj+1)
        #self.state_tuple = self.get_state_tuple()
        self.encoded_state_length = len(self.encode_state())
        self.action_map = {0: "Remove Crosing",
                         1: "Move Down",
                         2: "Move Up",
                         3: "Move Left",
                         4: "Move Right",
                         5: "Cut",
                         6: "Add Positive r2",
                         7: "Add Negative r2",
                         8: "Remove r2",
                         9: "r3",
                         10: "Far comm",
                         11: "Add Positive crossing",
                         12: "Add Negative crossing"}
        self.inverse_action_map = {"Remove Crossing": 0,
                                 "Move Down": 1,
                                 "Move Up": 2,
                                 "Move Left": 3,
                                 "Move Right": 4,
                                 "Cut": 5,
                                 "Add Positive r2": 6,
                                 "Add Negative r2": 7,
                                 "Remove r2": 8,
                                 "r3": 9,
                                 "Far comm": 10,
                                 "Add Positive crossing": 11,
                                 "Add Negative crossing": 12}
        # Define the action space for Gym, the list of integers from 0 to 12 inclusive.
        self.action_space = spaces.Discrete(13)
        # Define the lower and upper bounds for the observations space.
        self.observation_space = spaces.Box(low = self.low_bound,high = self.high_bound,dtype = np.int64)
        self.action_count = 0
        self.seed()
        self.done = False
        self.action_list = {}
        metadata = {"render.modes": ["human"]}
        self.matrix_size = self.max_possible_index*(self.max_possible_index-1)//2
        self.matrices = {}
        for jjj in range(-self.max_possible_index+1,self.max_possible_index):
            sgn = np.sign(jjj)
            if sgn == -1:
                self.matrices[jjj] = np.linalg.inv(self.LKrep(self.max_possible_index,np.abs(jjj)))
            elif sgn == 1:
                self.matrices[jjj] = self.LKrep(self.max_possible_index,np.abs(jjj))
            elif sgn == 0:
                self.matrices[jjj] = np.identity(self.matrix_size)
       
    def matrix_index(self,n,i,j):
        return int((i-1)*(n-i/2)+j-i-1)
    
    def LKrep(self,n,k):
        M = np.zeros((n*(n-1)//2,n*(n-1)//2))
        q = np.sqrt(2)
        t = np.pi
        for iii in range(1,n):
            for jjj in range(iii+1,n+1):
                if (k<iii-1)or(jjj<k):
                    M[self.matrix_index(n,iii,jjj),self.matrix_index(n,iii,jjj)] = 1
                elif k == iii-1:
                    M[self.matrix_index(n,iii-1,jjj),self.matrix_index(n,iii,jjj)] =  1
                    M[self.matrix_index(n,iii,jjj),self.matrix_index(n,iii,jjj)] = 1-q
                elif (k == iii) and (k<jjj-1):
                    M[self.matrix_index(n,iii,iii+1),self.matrix_index(n,iii,jjj)] = t*q*(q - 1)
                    M[self.matrix_index(n,iii+1,jjj),self.matrix_index(n,iii,jjj)] = q
                elif (k == iii) and (k == jjj-1):
                    M[self.matrix_index(n,iii,jjj),self.matrix_index(n,iii,jjj)] = t*q*q
                elif (iii<k) and (k<jjj - 1):
                    M[self.matrix_index(n,iii,jjj),self.matrix_index(n,iii,jjj)] = 1
                    M[self.matrix_index(n,k,k+1),self.matrix_index(n,iii,jjj)] = t*q**(k - iii)*(q - 1)**2
                elif (k == jjj-1):
                    M[self.matrix_index(n,iii,jjj-1),self.matrix_index(n,iii,jjj)] = 1
                    M[self.matrix_index(n,jjj-1,jjj),self.matrix_index(n,iii,jjj)] = t*q**(jjj-iii)*(q - 1)
                elif (k == jjj):
                    M[self.matrix_index(n,iii,jjj),self.matrix_index(n,iii,jjj)] = 1-q
                    M[self.matrix_index(n,iii,jjj+1),self.matrix_index(n,iii,jjj)] = q
        return M
    

    
    def full_braid_matrix(self):
        """ 
        Returns a matrix that represents the full braid.
        """
        mat = np.identity(self.matrix_size)
        for jjj in self.word:
            mat = mat@self.matrices[jjj]
        return mat
        

    # Takes as input a required position (corresponding to a letter in the braid word, indexed starting at 0), and an 
    # optional pair of strands (if the strands are ommited, the two strands involved in the crossing at the given 
    # position are chosen).  The strands are numbered from 1 to self.max_possible_index.  Returns the position of the strands once 
    # they have been traced back up to the top of the braid word.
    def traceback(self,position,strand1 = -1,strand2 = -1):
        if len(self.word) == 0:
            return strand1,strand2
        if strand1+strand2 == -2:
            strand1 = np.abs(self.word[position])
            strand2 = np.abs(self.word[position])+1
        for jjj in range(position):
            if np.abs(self.word[position-1-jjj]) == strand1:
                strand1 += 1
            elif np.abs(self.word[position-1-jjj]) == strand1-1:
                strand1 -= 1
            if np.abs(self.word[position-1-jjj]) == strand2:
                strand2 += 1
            elif np.abs(self.word[position-1-jjj]) == strand2-1:
                strand2 -= 1
        return int(strand1), int(strand2) 
    
    # Takes as input a strand number.  If it corresponds to a component other than component 1 it returns immediately.  
    # Otherwise it runs through the length of the braid word, checking to see if that component is involved in any of 
    # the crossings in the braid word.  If it is, it returns having done nothing.  If the given strand is not involved
    # in any of the crossings, then it increments the euler characteristic of component 1, adds 1+self.bonus to the 
    # value of self.score.  It then deletes that strand from self.components, adds an extra strand with Euler 
    # characteristic 1, and changes all of the crossings in the braid words to account for the removal of the unlinked
    # strand.  STRANDS ARE NUMBERED AS USUAL IN BRAID NOTATION STARTING AT 1, NOT USING PYTHON ARRAY NOTATION 
    # STARTING AT 0.
    def unlinked_strand_check(self,strand):
        if self.mode == "simple_ribbon_train" or self.mode == "simple_ribbon_test":
            return
        # If the strand corresponds to a component other than component 1 it returns immediately.
        if self.components[strand-1] != 1:
            return
        # If the strand corresponds to component number 1, then run through the length of the braid word, checking to 
        # see if that strand is involved in any of the crossings in the braid word.  If it is, it returns having done 
        # nothing.
        for jjj in range(len(self.word)):
            if np.abs(self.word[jjj]) == strand-1 or np.abs(self.word[jjj]) == strand:
                return
        # If the given strand is not involved in any of the crossings, increment the Euler characteristic by one, and 
        # change the score by one plus the value of self.bonus.
        self.eulerchar[1] += 1
        self.score += self.bonus+1
        # Delete the component corresponding to the unlinked strand that is being deleted.
        self.components = np.delete(self.components,strand-1)
        # Add a new strand to the component list with new component number, and set its Euler characteristic to one.
        self.components = np.append(self.components,self.current_index+1+self.extra_strands)
        self.extra_strands += 1
        self.eulerchar[self.components[-1]] = 1
        # Change the crossing number of all letters with crossing number greater than or equal to the deleted strand
        # number.  
        for jjj in range(len(self.word)):
            if self.word[jjj] >= strand+1:
                self.word[jjj] -= 1
            if -self.word[jjj] >= strand+1:
                self.word[jjj] += 1
#####        # Shift the cursor position to the left one space if it sits to the right of the strand being deleted.
#####        #if self.cursor[1]>strand:
#####            #self.cursor[1] -= 1


    def arrange_components(self):
        if self.mode == "simple_ribbon_train" or self.mode == "simple_ribbon_test":
            return
        current_comp = -2
        temp_eulerlist = {1:self.eulerchar[1]}
        complist = self.components
        for lll in complist:
            if lll>1:
                for www in np.where(complist == lll)[0]:
                    complist[www] = current_comp
                temp_eulerlist[np.abs(current_comp)] = self.eulerchar[lll]
                current_comp -= 1
        self.eulerchar = temp_eulerlist
        self.components = np.abs(complist) 

                
    # Moves the cursor position up (thinking of the braid as written from top to bottom).
    def move_up(self):
        if self.cursor[0] >= 1:
            self.cursor[0] -= 1
        else:
            self.cursor[0] = len(self.word)
            
    # Moves the cursor position down (thinking of the braid as written from top to bottom).        
    def move_down(self):
        if self.cursor[0] <= len(self.word)-1:
            self.cursor[0] += 1
        else:
            self.cursor[0] = 0
            
    # Moves the cursor position right (thinking of the strands as being written left to right starting at 1).
    def move_right(self):
        if self.cursor[1] <= self.current_index-2:
            self.cursor[1] += 1
        else:
            self.cursor[1] = 1
            
    # Moves the cursor position left (thinking of the strands as being written left to right starting at 1).        
    def move_left(self):
        if self.cursor[1] >= 2:
            self.cursor[1] -= 1
        else:
            self.cursor[1] = self.current_index-1
    
    # Cuts the braid at the position in the cursor, and moves the subword before the cursor to the end of the braid.
    # It also modifies the component list appropriately, before setting the position of the cursor to the beginning of
    # the new braid word.
    def cut(self):
        for iii in range(self.cursor[0]):
            a = (self.components[np.abs(self.word[iii])-1])
            b = (self.components[np.abs(self.word[iii])])
            self.components[np.abs(self.word[iii])-1] = b
            self.components[np.abs(self.word[iii])] = a
        self.word = np.concatenate((self.word[self.cursor[0]:],self.word[:self.cursor[0]]))
        self.cursor[0] = 0
        self.arrange_components()
     
    # Inserts a pair of cancelling crossings (positive, then negative) to the braid word at the location specified by
    # the cursor.  If the resulting braid word would have length larger than self.max_braid_length, then it does
    # nothing.
    def r2_add_pos(self):
        if len(self.word) >= self.max_braid_length-1:
            return
        self.word = np.concatenate((self.word[:self.cursor[0]],np.array([self.cursor[1],-self.cursor[1]]),self.word[self.cursor[0]:]))
        self.arrange_components()
    
    # Inserts a pair of cancelling crossings (negative, then positive) to the braid word at the location specified by
    # the cursor.  If the resulting braid word would have length larger than self.max_braid_length, then it does
    # nothing.
    def r2_add_neg(self):
        if len(self.word) >= self.max_braid_length-1:
            return
        self.word = np.concatenate((self.word[:self.cursor[0]],np.array([-self.cursor[1],self.cursor[1]]),self.word[self.cursor[0]:]))
        self.arrange_components()
    
    
    # Starts scanning the braid word at the position specified by the cursor, then removes the first instance of a pair
    # of letters of the form (a,-a).  If none exist, no action is taken.
    def r2_rm(self):
        for iii in range(len(self.word)):
            if self.word[(iii+self.cursor[0])%len(self.word)] == -self.word[(iii+self.cursor[0]+1)%len(self.word)]:
                left_strand = np.abs(self.word[(iii+self.cursor[0])%len(self.word)]) 
                right_strand = left_strand+1
                strand1,strand2 = self.traceback((self.cursor[0]+iii)%len(self.word),left_strand,right_strand)
                # If the two crossings to be removed are at the first and last position of the braid, the components of
                # the corresponding strands must be swapped.  
                if (iii+self.cursor[0]+1)%len(self.word) == 0:
                    a = self.components[left_strand-1]
                    b = self.components[right_strand-1]
                    self.components[left_strand-1] = b
                    self.components[right_strand-1] = a
                # Deletes the corresponding crossings from the braid words.
                loc1 = max((iii+self.cursor[0])%len(self.word),(iii+self.cursor[0]+1)%len(self.word))
                loc2 = min((iii+self.cursor[0])%len(self.word),(iii+self.cursor[0]+1)%len(self.word))
                self.word = np.delete(self.word,loc1)
                self.word = np.delete(self.word,loc2)
                ##########
                ###### Check the strands involved in the cancelling pair to see if they are now unlinked (checking the
                ###### larger of the two first, so that if it is deleted it doesn't mess up the number of the other one).
                #####for jjj in np.where(self.components == 1)[0]:
                    #####self.unlinked_strand_check(jjj+1)
                ##########
                # Check for unlinked strands of component number 1, starting at the right and moving left so as to not miss 
                # any strands from component number 1.
                comp_1_list = np.where(self.components == 1)[0]
                for jjj in range(len(comp_1_list)):
                    self.unlinked_strand_check(comp_1_list[-jjj-1]+1)
                #####self.unlinked_strand_check(max(strand1,strand2))
                #####self.unlinked_strand_check(min(strand1,strand2))
                # If the cursor position is now outside the length of the word, set it to the beginning of the word.
                if self.cursor[0]>len(self.word):
                    self.cursor[0] = len(self.word)
                break
        self.arrange_components()
    ######## FIGURE OUT WHERE TO CHANGE CURSOR POSITION   
    
    
    
    # Start scanning the braid word at the position specified by the cursor, then apply a Reidemeister 3 move at the 
    # position it's possible to.
    def r3(self):
        for iii in range(len(self.word)):
            loc1 = (iii+self.cursor[0])%len(self.word)
            loc2 = (iii+self.cursor[0]+1)%len(self.word)
            loc3 = (iii+self.cursor[0]+2)%len(self.word)
            if self.word[loc1] == self.word[loc3] and np.abs(self.word[loc1]-self.word[loc2]) == 1:
                if (iii+self.cursor[0]+1)%len(self.word) == 0 or (iii+self.cursor[0]+2)%len(self.word) == 0:
                    eps = np.abs(self.word[loc2])-np.abs(self.word[loc1])
                    if eps == 1:
                        left_strand = np.abs(self.word[loc1])
                        middle_strand = left_strand+1
                        right_strand = left_strand+2
                        a = self.components[left_strand-1]
                        b = self.components[middle_strand-1]
                        c = self.components[right_strand-1]
                        self.components[left_strand-1] = b
                        self.components[middle_strand-1] = c
                        self.components[right_strand-1] = a
                    elif eps == -1:
                        middle_strand = np.abs(self.word[loc1])
                        left_strand = middle_strand-1
                        right_strand = middle_strand+1
                        a = self.components[left_strand-1]
                        b = self.components[middle_strand-1]
                        c = self.components[right_strand-1]
                        self.components[left_strand-1] = c
                        self.components[middle_strand-1] = a
                        self.components[right_strand-1] = b
                letter1 = (self.word[loc1])
                letter2 = (self.word[loc2])
                self.word[loc1] = letter2
                self.word[loc3] = letter2
                self.word[loc2] = letter1
                break
            elif self.word[loc1] == -self.word[loc3] and np.abs(np.abs(self.word[loc1])-np.abs(self.word[loc2])) == 1:
                if (iii+self.cursor[0]+1)%len(self.word) == 0 or (iii+self.cursor[0]+2)%len(self.word) == 0:
                    eps = np.abs(self.word[loc2])-np.abs(self.word[loc1])
                    if eps == 1:
                        left_strand = np.abs(self.word[loc1])
                        middle_strand = left_strand+1
                        right_strand = left_strand+2
                        a = self.components[left_strand-1]
                        b = self.components[middle_strand-1]
                        c = self.components[right_strand-1]
                        self.components[left_strand-1] = b
                        self.components[middle_strand-1] = c
                        self.components[right_strand-1] = a
                    elif eps == -1:
                        middle_strand = np.abs(self.word[loc1])
                        left_strand = middle_strand-1
                        right_strand = middle_strand+1
                        a = self.components[left_strand-1]
                        b = self.components[middle_strand-1]
                        c = self.components[right_strand-1]
                        self.components[left_strand-1] = c
                        self.components[middle_strand-1] = a
                        self.components[right_strand-1] = b
                letter1 = (self.word[loc1])
                letter2 = (self.word[loc2])
                letter3 = (self.word[loc3])
                sign = np.sign(letter1)*np.sign(letter2)
                self.word[loc1] = np.abs(letter2)*np.sign(letter3)
                self.word[loc2] = sign*letter1
                self.word[loc3] = sign*letter2
                break
        self.arrange_components()
    ######## FIGURE OUT WHERE TO CHANGE CURSOR POSITION           
    
     
    # Start scanning the braid word at the position specified by the cursor, then swap the first two letters which 
    # in absolute value by two or greater.
    def far_comm(self):
        for iii in range(len(self.word)):
            loc1 = (iii+self.cursor[0])%len(self.word)
            loc2 = (iii+self.cursor[0]+1)%len(self.word)
            # If the two crossings to be swapped are at the beggining and end of the word respectively, then we alter
            # the component list accordingly.  
            if np.abs(np.abs(self.word[loc1])-np.abs(self.word[loc2])) >= 2:
                if (iii+self.cursor[0]+1)%len(self.word) == 0:
                    left_strand1 = np.abs(self.word[loc1])
                    right_strand1 = left_strand1+1
                    left_strand2 = np.abs(self.word[loc2])
                    right_strand2 = left_strand2+1
                    a1 = self.components[left_strand1-1]
                    b1 = self.components[right_strand1-1]
                    a2 = self.components[left_strand2-1]
                    b2 = self.components[right_strand2-1]
                    self.components[left_strand1-1] = b1
                    self.components[right_strand1-1] = a1
                    self.components[left_strand2-1] = b2
                    self.components[right_strand2-1] = a2
                letter1 = self.word[loc1]
                letter2 = self.word[loc2]
                self.word[loc1] = letter2
                self.word[loc2] = letter1
                break
        self.arrange_components()
                
    # Adds a positive crossing at the position specified by the cursor.  If the length of the resulting word would
    # exceed self.max_braid_length then nothing is done.
    def add_crossing_pos(self):
        if len(self.word) >= self.max_braid_length:
            return
        self.word = np.concatenate((self.word[:self.cursor[0]],[self.cursor[1]],self.word[self.cursor[0]:]))
        # Change the components of the corresponding strands to make them both the value of the smaller of the two 
        # components.
        strand1,strand2 = self.traceback(self.cursor[0])
        comp1 = self.components[strand1-1]
        comp2 = self.components[strand2-1]
        mincomp = min(comp1,comp2)
        maxcomp = max(comp1,comp2)
        for jjj in range(len(self.components)):
            if self.components[jjj] == comp1 or self.components[jjj] == comp2:
                self.components[jjj] = mincomp
        # If the components of the corresponding strand were already the same, then the Euler characteristic decreases
        # by one.
        if comp1 == comp2:
            self.eulerchar[mincomp] -= 1
            if mincomp == 1:
                self.score -= 1
        # If the components of the corresponding strands were not equal, then the Euler characteristic of the resulting
        # component is the sum of the Euler characteristics of the two components minus one.
        else:
            self.eulerchar[mincomp] = self.eulerchar[comp1]+self.eulerchar[comp2]-1
            # If the smaller of the two components was component number 1, we update the score along with the Euler
            # characteristic of the strand.
            if mincomp == 1:
                self.score = self.score+self.eulerchar[maxcomp]-1
            # Delete the record of the Euler characteristic of the larger of the two components.
            del self.eulerchar[maxcomp]
        # Check for unlinked strands of component number 1, starting at the right and moving left so as to not miss 
        # any strands from component number 1.
        comp_1_list = np.where(self.components == 1)[0]
        for jjj in range(len(comp_1_list)):
            self.unlinked_strand_check(comp_1_list[-jjj-1]+1)
        self.arrange_components()
            
    # Adds a negative crossing at the position specified by the cursor. If the length of the resulting word would
    # exceed self.max_braid_length then nothing is done.           
    def add_crossing_neg(self):
        if len(self.word) >= self.max_braid_length:
            return
        self.word = np.concatenate((self.word[:self.cursor[0]],[-self.cursor[1]],self.word[self.cursor[0]:]))
        # Change the components of the corresponding strands to make them both the value of the smaller of the two 
        # components.
        strand1,strand2 = self.traceback(self.cursor[0])
        comp1 = self.components[strand1-1]
        comp2 = self.components[strand2-1]
        mincomp = min(comp1,comp2)
        maxcomp = max(comp1,comp2)
        for jjj in range(len(self.components)):
            if self.components[jjj] == comp1 or self.components[jjj] == comp2:
                self.components[jjj] = mincomp
        # If the components of the corresponding strand were already the same, then the Euler characteristic decreases
        # by one.
        if comp1 == comp2:
            self.eulerchar[mincomp] -= 1
            if mincomp == 1:
                self.score -= 1
        # If the components of the corresponding strands were not equal, then the Euler characteristic of the resulting
        # component is the sum of the Euler characteristics of the two components minus one.
        else:
            self.eulerchar[mincomp] = self.eulerchar[comp1]+self.eulerchar[comp2]-1
            # If the smaller of the two components was component number 1, we update the score along with the Euler
            # characteristic of the strand.
            if mincomp == 1:
                self.score = self.score+self.eulerchar[maxcomp]-1
            # Delete the record of the Euler characteristic of the larger of the two components.
            del self.eulerchar[maxcomp]
        # Check for unlinked strands of component number 1, starting at the right and moving left so as to not miss 
        # any strands from component number 1.
        comp_1_list = np.where(self.components == 1)[0]
        for jjj in range(len(comp_1_list)):
            self.unlinked_strand_check(comp_1_list[-jjj-1]+1)
        self.arrange_components()
            
            
    # Remove the crossing at the position specified by the cursor.  
    def rm_crossing(self):
        if len(self.word) == 0:
            return
        if self.cursor[0] == len(self.word):
            self.cursor[0] = 0
        # Change the components of the corresponding strands to make them both the value of the smaller of the two 
        # components.
        strand1,strand2 = self.traceback(self.cursor[0])
        self.word = np.delete(self.word,self.cursor[0])
        comp1 = self.components[strand1-1]
        comp2 = self.components[strand2-1]
        mincomp = min(comp1,comp2)
        maxcomp = max(comp1,comp2)
        for jjj in range(len(self.components)):
            if self.components[jjj] == comp1 or self.components[jjj] == comp2:
                self.components[jjj] = mincomp
        # If the components of the corresponding strand were already the same, then the Euler characteristic decreases
        # by one.
        if comp1 == comp2:
            self.eulerchar[mincomp] -= 1
            if mincomp == 1:
                self.score -= 1
        # If the components of the corresponding strands were not equal, then the Euler characteristic of the resulting
        # component is the sum of the Euler characteristics of the two components minus one.
        else:
            self.eulerchar[mincomp] = self.eulerchar[comp1]+self.eulerchar[comp2]-1
            # If the smaller of the two components was component number 1, we update the score along with the Euler
            # characteristic of the strand.
            if mincomp == 1:
                self.score = self.score+self.eulerchar[maxcomp]-1
            # Delete the record of the Euler characteristic of the larger of the two components.
            del self.eulerchar[maxcomp]
        # Check for unlinked strands of component number 1, starting at the right and moving left so as to not miss 
        # any strands from component number 1.
        comp_1_list = np.where(self.components == 1)[0]
        for jjj in range(len(comp_1_list)):
            self.unlinked_strand_check(comp_1_list[-jjj-1]+1)
        #####self.unlinked_strand_check(max(strand1,strand2))
        #####self.unlinked_strand_check(min(strand1,strand2))
        self.arrange_components()
######## FIGURE OUT WHERE TO CHANGE CURSOR POSITION        
        
    
    
### TODO: Add function that removes all strands besides component 1, then checks for triviality of resulting braid.    
    
    # Check if the braid is in a terminal state.  It is a terminal state if it has length zero or if none of the 
    # strand correspond to component number one.  
    def is_Terminal(self):
        # Check if the braid word has length 0, if so, return True.
        if len(self.word) == 0:
            return True
        # Check if the braid is isotopic to the trivial braid.  
        if np.allclose(np.identity(self.matrix_size),self.full_braid_matrix()):
            return True
        # Check if there are any strands with component number one, if so, return False.  
        for jjj in range(len(self.components)):
            if self.components[jjj] == 1:
                return False
        return False
        
    
    # Function to display information of the current state of the braid word.
    def info(self):
        print("Braid word:\t\t",self.word)
        print("Component list:\t\t",self.components)
        print("Euler characteristics:\t",self.eulerchar)
        print("Score:\t\t\t",self.score)
        print("Cursor:\t\t\t",self.cursor)
        print("Is Terminal:\t\t",self.is_Terminal())
    
  

    # One-hot encodes the cursor position and the braid word.  
    def one_hot(self):
        # Initializes the one-hot array.
        self.one_hot_word = 0.25*np.ones(2*(self.max_possible_index-1)*(self.max_braid_length)+(self.max_braid_length+1)+(self.max_possible_index-1))
        # Encode the cursor position.
        self.one_hot_word[self.cursor[0]] = 0.75
        self.one_hot_word[self.cursor[1]+self.max_braid_length] = 0.75
        self.offset = self.max_braid_length+self.max_possible_index-1
        # Encode the braid word.
        for jjj in range(len(self.word)):
            self.one_hot_word[self.offset+jjj*2*(self.max_possible_index-1)+(np.sign(self.word[jjj])+1)//2*self.word[jjj]-(np.sign(self.word[jjj])-1)//2*(np.abs(self.word[jjj])+self.max_possible_index-1)] = 0.75
        return self.one_hot_word
    
    # Combines the above one-hot encoding with a one-hot encoding of the component list and euler characteristic 
    # (though it does not capture any component numbers larger than the index, which could have been added later in the
    # process).
    def full_one_hot(self):
        self.ohmat = 0.25*np.ones((self.max_possible_index+1,self.max_possible_index))
        for jjj in range(self.max_possible_index):
            if self.components[jjj] <= self.max_possible_index:
                self.ohmat[jjj,self.components[jjj]-1] = 0.75
            self.ohmat[self.max_possible_index,jjj] = self.eulerchar[self.components[jjj]]
        foh = np.concatenate((self.one_hot(),np.reshape(self.ohmat,self.max_possible_index*(self.max_possible_index+1))))
        return foh
    
    def print_braid(self):
        down_arrow = "\u2193"
        right_arrow = "\u2192"
        row = self.cursor[0]
        column = self.cursor[1]
        if len(self.word) ==  0:
            print(" ", end = "")
            print(" "*(2*column-1), end = '')
            print(down_arrow)
            print(" ", end = "") 
            print("| "*(self.current_index))           
            print(right_arrow, end = '')
            print("| "*(self.current_index))
            return
        print(" "*(2*column-1)+" ", end = '')
        print(down_arrow)
        print(" ", end = "")
        print("| "*self.current_index)
        i = 1
        for cross in self.word:
            if i ==  row+1:
                print(right_arrow, end = "")
            else:
                print(" ", end = "")
            print("| "*(abs(cross)-1), end = '')
            if cross > 0:
                print(" /  ", end = '')
            else:
                print(" \  ", end = '')
            print("| "*(self.current_index - abs(cross) - 1))
            i  +=  1
        if i ==  row+1:
            print(right_arrow, end = "")
        else:
            print(" ", end = "")
        print("| "*self.current_index)
    
    def print_action_sequence(self, action_list, gamma = 0.99):
        self.info()
        self.print_braid()
        reward_seq = []
        for action in action_list:
            reward, _, _ = self.action(action)
            reward_seq.append(reward)
            print(" = "*60)
            print("Action {}: {}".format(action, self.action_map[action]))
            print("Reward: {}".format(reward))
            print(" = "*60)
            self.info()
            self.print_braid()
    
    def encode_state(self, zero = 0, one = 1, display = False):
        """updated encode_state() function. Uses lists instead of numpy arrays. New implementation
        is 3-4 times faster.
        By Spencer
        Encodes our state for input into a neural network
        The braid, component list, and cursor positions are one-hot-encoded while the Euler 
        components are simply put in since they are unbounded.
        braid encoding"""
        encoded = []
        braid_encoding = []
        #padded zeros encoding
        for i in range(self.max_braid_length-len(self.word)):
            code = [zero for i in range(2*(self.max_possible_index)-1)]
            index = self.max_possible_index-1
            code[index] = one
            braid_encoding += code
        #crossings encoding
        for crossing in self.word:
            code = [zero for i in range(2*(self.max_possible_index)-1)]
            index = self.max_possible_index-1+crossing
            code[index] = one
            braid_encoding += code
        
        encoded += braid_encoding
        comp_encoding = []
        #component list encoding
        for component in self.components:
            code = [zero for i in range(self.max_possible_index+1)]
            code[component-1] = one
            comp_encoding += code
        encoded += comp_encoding
        euler_encoding = []
        #Euler list encoding
        code = [zero for i in range(len(self.components))]
        try:
            for i in range(len(self.components)):
                code[i] = self.eulerchar[self.components[i]]
        except KeyError:
            print("Key Error: {}".format(self.components[i]))
            print("Components: {}".format(self.components))
            print("Eulerchar: {}".format(self.eulerchar))
        euler_encoding += code     
        encoded += euler_encoding
        #Cursor position encoding
        #row cursor encoding
        cursor_encoding = []
        code = [zero for i in range(self.max_braid_length+1)]
        index = self.cursor[0]
        code[index] = one
        cursor_encoding += code
        #column cursor encoding
        code = [zero for i in range(self.max_possible_index-1)]
        index = self.cursor[1]-1
        code[index] = one
        cursor_encoding += code
        
        encoded += cursor_encoding
        if display:
            line_length = 100
            print(" = "*line_length)
            print("State Encoding")
            self.info()
            print("Braid encoding length: {}".format(len(braid_encoding)))
            print("Braid encoding: {}\n".format(braid_encoding))
            print("Component encoding length: {}".format(len(comp_encoding)))
            print("Component encoding: {}\n".format(comp_encoding))
            print("Euler encoding length: {}".format(len(euler_encoding)))
            print("Euler encoding: {}\n".format(euler_encoding))
            print("Cursor encoding length: {}".format(len(cursor_encoding)))
            print("Cursor encoding: {}]\n".format(cursor_encoding))
            print("Full encoding length: {}".format(len(encoded)))
            print("Full encoding: {}\n".format(encoded)) 
            print(" = "*line_length)
        return np.array(encoded)
    
    def complete_state(self):
        """ Gathers all state information into a single vector, without using one hot encoding. """
        if self.mode == "simple_ribbon_train" or self.mode == "simple_ribbon_test":
            state = list(self.word)+[0 for jjj in range(self.max_braid_length-len(self.word))]+list(self.cursor)
        else:
            state = list(self.word)+[0 for jjj in range(self.max_braid_length-len(self.word))]+list(self.cursor)+list(self.components)+[self.eulerchar[jjj] for jjj in self.components]
        return state
    
    
    def reset(self):
        #print("Episode ", self.episode_count, " reset after ", self.action_count, " steps. \n reward = ", self.eulerchar[1],
              #"\n original braid word = ",self.starting_word,"\n length = ",len(self.starting_word),"\n \n")
        if self.eulerchar[1]>1:
            print("starting braid = ",self.starting_word,"\n component list = ",self.components,"\n euler char = ",self.eulerchar,"\n action list = ",self.action_list)
        self.episode_count += 1
        if self.mode == "simple_ribbon_train" and self.starting_braid == "random":
            self.initial_index = min(np.random.choice(np.arange(self.min_index_parameter, self.min_index_parameter+self.episode_count*self.index_parameter, dtype = int)), self.max_possible_index)
            self.current_index = self.initial_index
            self.max_initial_braid_length = min(np.random.choice(np.arange(self.min_length_parameter, self.min_length_parameter+self.episode_count*self.length_parameter, dtype = int)), self.max_possible_initial_braid_length)
            self.initial_band_count = np.random.choice(np.arange(self.min_band_parameter, self.min_band_parameter+self.episode_count*self.band_parameter, dtype = int))
            self.initial_band_count = min(max(self.initial_band_count, self.initial_index-1), self.max_possible_initial_band_count)
            self.entire_braid = bounded_random_braid(bound = self.max_initial_braid_length, 
                                                          max_initial_index = self.initial_index,
                                                          max_total_bands = self.initial_band_count,
                                                          seed_braid = False, 
                                                          slice_knot = self.train_on_slice_knots, 
                                                          fix_original_band_choices = True)
            self.starting_word = self.entire_braid[1]            
        elif self.mode == "simple_ribbon_train" and self.starting_braid != "random":
            self.starting_word = list(self.starting_braid)
            self.initial_index = max(np.abs(self.starting_word))+1
            self.current_index = self.initial_index
        elif self.mode == "simple_ribbon_test" and self.starting_braid == "random":
            self.initial_index = np.random.choice(np.arange(self.min_index_parameter, self.max_possible_index+1, dtype = int))
            self.current_index = self.initial_index
            self.max_initial_braid_length = np.random.choice(np.arange(self.min_length_parameter, self.max_possible_initial_braid_length+1, dtype = int))
            self.initial_band_count = np.random.choice(np.arange(self.min_band_parameter, self.max_possible_initial_band_count+1, dtype = int))
            self.initial_band_count = max(self.initial_band_count, self.initial_index-1)
            self.entire_braid = bounded_random_braid(bound = self.max_initial_braid_length, 
                                                          max_initial_index = self.initial_index,
                                                          max_total_bands = self.initial_band_count,
                                                          seed_braid = False, 
                                                          slice_knot = self.train_on_slice_knots, 
                                                          fix_original_band_choices = True)
            self.starting_word = self.entire_braid[1]
        elif self.mode == "simple_ribbon_test" and self.starting_braid != "random":
            self.starting_word = list(self.starting_braid)
            self.initial_index = max(np.abs(self.starting_word))+1
            self.current_index = self.initial_index
        else:
            dummy = 1
            # TODO: decide what to do here.
        # The numpy array that tracks the braid word representing the knot.
        self.word = np.array(self.starting_word) 
        assert len(self.word)  <=  self.max_braid_length, "Cannot initialize with braid with length longer than max_braid_length"
        self.extra_strands = 0
        # This list should have one entry for each strand in the braid word (self.max_possible_index number of them), and tracks 
        # which strands are on the same component.  
        # For example, if the list is [1,1,2,3,3] it means the first two strands belong to component number 1 of the 
        # surface created, the third strand belongs to component number 2, while the last two strands again belong to 
        # the same component, component number 3.
        self.components = np.zeros(self.max_possible_index,int)  
        self.component_count = 1
        # This assigns the component of starting_knot_strand the number 1.
        self.components[self.starting_knot_strand-1] = self.component_count
        self.temp_position = len(self.word)
        # Starting with the starting_knot_strand, we trace it back through the braid word to see what other strands it 
        # connects to.
        self.next_strand = self.traceback(self.temp_position,self.starting_knot_strand)[0]
        # Label the next strand on the same component as component number 1, and assign it an Euler characteristic of 0.
        self.components[self.next_strand-1] = self.component_count
        self.eulerchar = {1:0}
        # Iterate through the rest of the strands of the knot component, assigning them component number 1.
        while self.next_strand != self.starting_knot_strand:
            self.next_strand = self.traceback(self.temp_position,self.next_strand)[0]
            self.components[self.next_strand-1] = self.component_count
        # Iterate now through the remaining strands, assigning increasing values for each subsequent component.
        for jjj in range(self.max_possible_index):
            if self.components[jjj] == 0:
                self.component_count += 1
                self.new_starting_knot_strand = jjj+1
                self.components[self.new_starting_knot_strand-1] = self.component_count
                self.next_strand = self.traceback(self.temp_position,self.new_starting_knot_strand)[0]
                self.components[self.next_strand-1] = self.component_count
                while self.next_strand != self.new_starting_knot_strand:
                    self.next_strand = self.traceback(self.temp_position,self.next_strand)[0]
                    self.components[self.next_strand-1] = self.component_count   
        # Assign an euler characteristic of 1 to any components other than the knot component.
        for key in self.components:
            if key != 1:
                self.eulerchar[key] = 1
        # Initiate the score to 0.
        self.score = 0
        # Initiate the cursor position.
        self.cursor = np.array([0,1])
        # Run through the different strands.  If any strands corresponding to component number 1 are unlinked, delete them.
        for jjj in range(self.current_index):
            self.unlinked_strand_check(jjj+1)
        #self.state_tuple = self.get_state_tuple()
        self.encoded_state_length = len(self.encode_state())
        self.action_count = 0
        self.seed()
        self.done = False
        self.action_list = {}
        return self.complete_state()
    
    
    # Associating numbers 0 through 13 to the braid word actions defined above.
    def step(self, action_number):
        """Associating numbers 0 through 13 to the braid word actions defined above.
        This is also where the reward function for the MDP is implemented"""
        old_score = self.eulerchar[1]
        # Use the self.info variable to keep track of actions we have performed this episode.
        self.action_list[self.action_count] = action_number
        if action_number == 1:
            self.move_down()
        elif action_number == 2:
            self.move_up()
        elif action_number == 3:
            self.move_left()
        elif action_number == 4:
            self.move_right()
        elif action_number == 5:
            self.cut()
        elif action_number == 6:
            self.r2_add_pos()
        elif action_number == 7:
            self.r2_add_neg()
        elif action_number == 8:    
            self.r2_rm()
        elif action_number == 9:
            self.r3()
        elif action_number == 10:
            self.far_comm()
        elif action_number == 11:
            self.add_crossing_pos()
        elif action_number == 12:
            self.add_crossing_neg()
        elif action_number == 0:
            self.rm_crossing()
        else:
            assert True == False, "Invalid action passed: {}".format(action_number)
        for component in self.components:
            assert component > 0, "Error"
        state = self.complete_state()
        reward = -self.inaction_penalty+self.eulerchar[1]-old_score
        self.done = self.is_Terminal()
        if self.done and self.mode == "simple_ribbon_train":
            reward += self.current_index
            self.eulerchar[1] += self.current_index
        if self.done and self.reward_slice:
            reward += self.slice_bonus
        self.action_count += 1
        if self.action_count == self.max_actions:
            self.done = True
            reward -= self.final_penalty
        for component in self.components:
            assert component in self.eulerchar.keys(), "Components and Eulerchar have become misaligned. Components: {} Eulerchar: {}".format(self.components, self.eulerchar)
        return [state, reward, self.done, self.action_list]  
    
    
    def render(self,mode = "human"):
        self.info()
        print("Action list = ",self.action_list)
        self.print_braid()
        
        
    def seed(self,seed = None):
        # For instructions see https://medium.com/distributed-computing-with-ray/anatomy-of-a-custom-environment-for-rllib-327157f269e5
        self.np_random, seed = seeding.np_random(seed)
        return [seed]

from tqdm.auto import tqdm
from stable_baselines3.common.callbacks import BaseCallback

class ProgressBarCallback(BaseCallback):
    """
    :param pbar: (tqdm.pbar) Progress bar object
    """
    def __init__(self, pbar):
        super(ProgressBarCallback, self).__init__()
        self._pbar = pbar

    def _on_step(self):
        # Update the progress bar:
        self._pbar.n = self.num_timesteps
        self._pbar.update(0)

# this callback uses the 'with' block, allowing for correct initialisation and destruction
class ProgressBarManager(object):
    def __init__(self, total_timesteps): # init object with total timesteps
        self.pbar = None
        self.total_timesteps = total_timesteps
        
    def __enter__(self): # create the progress bar and callback, return the callback
        self.pbar = tqdm(total=self.total_timesteps)
            
        return ProgressBarCallback(self.pbar)

    def __exit__(self, exc_type, exc_val, exc_tb): # close the callback
        self.pbar.n = self.total_timesteps
        self.pbar.update(0)
        self.pbar.close()

"""### Experiments"""

config = {"mode": "simple_ribbon_train", 
          "initial_braid_lengths": [5,30],
          "initial_band_counts": [1,4],
          "initial_braid_indices": [2,5],
          "inaction_penalty": 0.05,
          "slice_bonus": 100,
          "final_penalty": 100,
          "train_on_slice_knots": True}

env = SliceEnv_v2(config = config)

# Do not execute this cell unless you want to retrain the agent.  With 2000000 times steps it will take ~30 minutes.

def train():
    model = PPO("MlpPolicy", env, verbose = 0, tensorboard_log="ppo_stable", ent_coef=0.1)

    #with ProgressBarManager(2000) as callback:
        #model.learn(total_timesteps=10000, callback=callback)
        #model.save("Slice_PPO")
    for i in range(2000):
        print(f"Epoch {i}")
        model.learn(total_timesteps=10000)
        model.save("Slice_PPO")

        if i % 25 == 0:
            state = env.reset()

            env.render()

    # A loop that will create a random grid diagram, then use the trained agent to simplify it.

            print("starting braid: ",env.word,"\n")
            iii = 0
            while not env.is_Terminal() and iii<550:
                iii+=1
                action, state = model.predict(state)
                #print("action: ",action,"\n")
                state, rewards, dones, info = env.step(action)
            print(f"reward {rewards}")
            print("word: ",env.word,"\n")
            

    #for jjj in range(100):
    #    model.learn(total_timesteps=10000)  # Progress bar not working for some reason.
    #    model.save("Slice_PPO")
    #   
    #    print(f"Done with {jjj}")
        
    model.save("Slice_PPO")

config = {"mode": "simple_ribbon_test", 
          "initial_braid_lengths": [5,30],
          "initial_band_counts": [1,4],
          "initial_braid_indices": [2,5],
          "inaction_penalty": 0.05,
          "slice_bonus": 100,
          "final_penalty": 100,
          "train_on_slice_knots": True}

def eval():

    env = SliceEnv_v2(config = config)

    model = PPO.load("Slice_PPO", env = env)

    state = env.reset()

    env.render()

    # A loop that will create a random grid diagram, then use the trained agent to simplify it.

    print("starting braid: ",env.word,"\n")
    iii = 0
    while not env.is_Terminal() and iii<550:
        iii+=1
        action, state = model.predict(state)
        #print("action: ",action,"\n")
        state, rewards, dones, info = env.step(action)
        #env.render()
        #print("word: ",env.word,"\n")
        
    #env.render()
    print(f"reward {reward}")
    print("word: ",env.word,"\n")

if __name__ == "__main__":
    train()
